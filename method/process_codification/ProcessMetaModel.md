## ProcessMetaRepo (МетаМодель Репозитария схем процессов) на TriG (quads)
Считаем синонимами: схема \ диаграмма \ граф. МетаМодель Репозитария, включая МетаМодель Схемы Процесса (MetaModelDia).  
Овновное вопрос: Как кодировать subject (ID процесса) в turtle RDF.  
### А. Базовые положения:
1. Используем именованные графы TriG (quads)
2. Используем два графовых пространства: 
2.1. Граф Design, где формируются дерево образов процессов: дерево процессов (шаблоны, образцы, прототипы и т.п.);  
2.2. Набор графов – схем (diagram) для каждого процесса, граф «Dia». 
### Б. Граф Design
В графе Design задается иерархия (дерево иерархии) и фиксируется наличие схемы процесса. Введем два типа схем (для начала): структурные (Str = structural diagram) и «добавленного качества» (VAD): 
:хх vad:hasDiaType vad:StrType .
:хх vad:hasDiaType vad:VadType .
Если процесс не имеет свойства vad:hasDiaType, то считаем, что он не имеет схемы процесса (диаграммы), т.е. этот процесс не детализирован (нет раскрытия процесса в виде схемы).
В коде процесса указываем первую «p», в коде графа первую «g». 
Что бы показать иерархию процессов используем отношение vad:hasParent (обратное vad:hasChald). В дереве процессов (графе Design) всегда есть ровно один родитель, т.е. нет повторов и соблюдается уникальность кода, id. Причем он (id материнского процесса) может быть вычислен: если номер процесса 1_3, то его родительский процесс 1. Однако это верно только для номерных процессов. Процесс номерной – если он имеет детализацию. Для процессов верхнего уровня (1, 2, 3 и т.д.) родительский элемент p0 (ProcessRoot). 
В дереве процессов будет фактичсекм две части: верхняя - дерево номерных процессов (у которых есть детализация) и нижняя - дерево ненумерных процессов (без детализации).
### В. Дубли процессов (объектов) 
В схемах процесса может быть более одного одноименного процесса, т.е. есть повторы одного и того же процесса на одной схеме (диаграмме, графе). В этом случае первый процесс кодируется также, как будто он единственный, например, p1_2_Process_1_2. Следующий его дубль в этой схеме кодируется как  p1_2_Process_1_2#2. Для кода p1_2_Process_1_2 можно считать, что он всегда имеет окончание #1, которое «не пишется». 
Вопрос: знак «#» точно нам подойдет, может быть лучше другой, который не является служебным в синтаксисе  RDF \ TriG? Может быть лучше «!»?
Соответственно p1_2_Process_1_2 и p1_2_Process_1_2#2 одного графа схемы процесса отображаются (сопоставляются) с одним и тем же p1_2_Process_1_2 в графе дерева процессов (граф Design). Нужно как-то учитывать в запросах использование «#», например, при запросах: 
- Отобрать все процессы p1_2_Process_1_2 с дублями, в результат должны попасть p1_2_Process_1_2 и p1_2_Process_1_2#2; 
- Отобрать все процессы p1_2_Process_1_2 без дублей, в результат должен попасть только p1_2_Process_1_2.
### Г. Вычисление id процесса 
На начальном этапе id процесса (подпроцесса) будем вычислять по названию процесса путем замены пробелов в названии на “_”, например, «Разработка схемы» даст id = Разработка_схемы. 
Другие варианты кодирования (просто для сравнения) id для элементов (узлов, shape) схемы:
- использовать уникальный «большой» и непонятный код, например, как в drawio или ARIS;
- кодировать каждый элемент последовательно порядковым номером;
- кодировать элемент в соответствии с его типом, получая составной элемент, например, StrType.22 или VadType.33. В visio к имени .master добавляется следующий порядковый номер.
Однако, нам важно, чтобы id был человеко - читаемым. Для упрощения для номерных процессов оставляем только номер процесса, а для ненумернных - имя процесса с заменой пробелов на «_».  
### Итого
Получились в итоге следующие составляющие ProcessMetaRepo: 
- две области схем \ графов: дерево процессов (все процессы в иерархии, т.е. без дублей) и дерево схем процессов;
- MetaModelDia, включающая формат схемы процесса: заголовок процесса (желтый прямоугольник вверху схемы) и составные части процесса (элементы, VAD-кораблики), которые при наличие дублей их кодируют через символ "#".
Вроде бы с кодированием subject ясность появилась, что нужно опробировать.
## ProcessMetaModel (метаМодель процесса). Triples vs Quads (выбрали Quads). Архивное
### 1 Основная часть
Все объекты включаются в дерево и в графы. В дерево объект входит только один раз и на основе адреса в дереве формируется уникальный адрес объекта. Для простоты будем считать, что объект – это процесс или его подпроцесс. 
Таким образом, есть
1. дерево процессов – это иерархический справочник (таксономия) процессов, на основе которого формируется адрес id \ iri процесса, а также его url – адрес, куда будет переход по клику из любой схемы EKG.
2. схема процесса, читай граф процесса, точнее локальный граф - в нем нет всех связей с элементами этого процесса, см. схему Process_1 – где не показана связь с Process_1_3, которая показана на схеме Process_2.
На рис. ниже зеленым показаны «родные» процессы (собственные), а синим «чужие» (заимствованные) процессы. Для «родных» процессов используем отношение :hasParent, а для чужих или ничего или :isExt (is external). Таким образом на схеме (графе) есть как собственные, так и заимствованные элементы. 

Задача – определить дерево  идентификаторов и принцип кодификации объектов.  
Вопрос: как лучше выстроить онтологию, как лучше кодировать (IRI \ URL) и упаковывать с файлы RDF? 
**Вариант «Triple»** gоказан на рисунке:
<img src="visioOntoVAD_VAD3a_1.png" width="1000" />
Оба файла .ttl лежат в [samples/vad_1_rdflib/JOIN](https://github.com/bpmbpm/SemanticBPM/tree/main/samples/vad_1_rdflib/JOIN). Их загрузка в triple store показана в exSparql_2.js

**Вариант Quad** подразумевает запись квадро с указанием идентификатора схемы (графа). Такая кодификация при замешивании любых файлов с триплетами позволит легко определять принуждённость элементов к конкретной схеме. При формировании triple store по варианту «Triple» выделение состава конкретной схемы процесса усложняется.

Общие предпосылки:
1. Один файл = одна схема (один граф) 
2. По URL обеспечивается доступ к элементу, который или идентичен IRI или легко сопоставим. Даже если не будет вызываться (не сможем рендерить в real-time) «хх.drawio» (или yEd), то будет одноименный html или svg.    
В пути URL \ IRI:
- EKG [Enterprise Knowledge Graph]( https://github.com/bpmbpm/doc/blob/main/README.md#enterprise-knowledge-graph)
- all_processes – папка \ ресурс со всеми процессами.
  
В целом: обсуждаем задачу кодирования \ идентификации (id, iri) объектов схемы процесса: процесса (желтый прямоугольник – название схемы) и его подпроцессов в виде VAD-корабликов. Сценарий: поиск элемента (процесса \ подпроцесса, схемы процесса) встроенным запросом или SPARQL и по результату запроса переход к нужной схеме (вывести схему в окно схем) и активировать нужный элемент схемы (перевести фокус на элемент, shape).   
Вопросы редактирования графики, формирование файлов RDF из .drawio \ yEd, загрузка RDF – файлов в triple store – тут не затрагиваем.     
Будем копии объектов (заимствованные процессы) назвать именно дубликатами, а не экземплярами, т.к. «экземпляром процесса» обычно называют исполняемый экземпляр – как запущенный процесс по шаблону «образа процесса»: мир идей vs мир вещей. Образ процесса (рисунок) vs экземпляр процесса (реально исполняемый). В ARIS – подобных системах нет исполняемых экземпляров процессов, в отличие от [WFE систем \WFE-engine]( https://habr.com/ru/articles/866822/).
### 2 Более подробное описание (для понимания будущих проблем)
На [Рис. 1 Базовый трафарет VAD – диаграммы и соответствующие семантические конструкции](https://habr.com/ru/articles/828266/) показан более сложный вариант, например, показаны типы предшествующий, последующий, элементы комментирования объекта и др. Предлагаю пока остановится на двух типах (см. "Основная часть"): Основной элемент (собственный) и внешний (заимствованный). Однако все в указанной статье (habr, рис.1) описывает именно подход к кодированию объектов, т.е. ровно то, что мы и хотим определить. К более сложной структуре процесса вернемся позже. Дублирую рис. 1:
<img src="https://habrastorage.org/getpro/habr/upload_files/993/0ea/6fe/9930ea6fe48d91b2baac8376b7a68670.png" width="1000" />
### 3 Откуда «ноги / уши растут» свой / чужой (читать опционально, имеет обзорное значение)
В той же статье [Semantic BPM. Онтологическое моделирование верхнеуровневых процессов. VAD](https://habr.com/ru/articles/828266/) уже упоминал аналогию:  
_Принцип схож с ГОСТ 2.711–82 ЕСКД Схема деления изделия на составные части (схема деления изделия \ процесса), где hasParent — это собственные процессы (изделия в 2.711), а isExt (Ext = external) — внешние (заимствованные) процессы (изделия). Это позволяет выстроить стройную иерархию идентификаторов процессов и построить единое дерево процессов на основе их идентификаторов. Обратные отношения показаны в скобках, т. е. это hasChild (имеет потомка) и hasEx (содержит внешний процесс)._ 

Расскажу более подробно. Есть «Схема деления изделия на составные части»: 
[1982](https://meganorm.ru/Data/301/30110.pdf) или [2023]( https://meganorm.ru/Data/816/81671.pdf) там указываются (упрощённо) два типа составных частей: свои и чужие, т.е. изделия собственной разработки и заимствованные у сторонних предприятий. За каждый предприятием закреплен свой Децимальный номер. 
[Децимальные номера](https://habr.com/ru/articles/452376/) имеют все изделия от винтика по программного модуля (ЕСПД).   Помню сцены (30 лет назад), когда Главный конструктор АСУ задумчиво стоит перед схемой деления размером 8х5 метров (склейка из листов А0) с конечными элементами (сотни шт.) на схеме следующих типов: «одноплатный компьютер», «радио-модуль пакетной радиостанции», «навигационный приемник» (тогда такой применик был размером с современный смартфон). Концепт «схемы деления предприятия на составные части» близок к EKG. 

Аналогия в том, что схема бизнес-процесса – это аналогия схемы изделия: все «свои» составные части обозначаются одним типом «вновь разработанные изделия» - у нас это «зеленые» (предикат hasParent c привязкой к родительскому процессу) и «заимствованные» - это у нас синие, считай – «чужие» / сторонние децимальные номера. Каждый элемент (составная часть изделия) имеет свой IRI, называемый децимальным номером составной части.
Пример [схемы деления](https://fizmat.space/engineering/files/%D0%9F%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8/02_K3D27V_Chernovik_Skhemy_delenia_v23Z_2024.pdf)

Кстати и месторасположение объектов, в нашем случае файлов – также идентично. В конструкторской документации есть оригинал (адрес архива, где хранятся оригиналы чертежей) и копии (дубликаты). У нас также: где бы ни встретился (в какой – любо схеме) какой – любо процесс (как заимствованный), он указывает на единственный адрес (IRI \ URL), где лежит его оригинал (оригинал его схемы).  
 
Фактически выше мы обсуждали как с помощью конкретного механизма кодирования (id/iri/url) и представдения знаний в атомарных записях (Triples vs Quads), что есть MDM (meta-data management), реализовать механизм "другого" MDM (master data management) - single source of truth. Децимальные номера изделий (ЕСКД \ ЕСПД), схема деления изделия на составные части (ГОСТ 2.711–82) это ровно про [оба этих MDM](https://www.stibosystems.com/blog/what-is-the-difference-between-master-data-and-metadata).
Однако, если концепт master data обычно сводится к выбору единого источника (БД) и репликации данных из него в другие системы, то на примере "Схемы деления изделия на составные части" хорошо видна визуализация этого же подхода в разработке документации. Причем наша визуализация процессов (EKG) точно повторяет даже внешне этот подход: мы точно также явно выделяем собственные и внешние к конкретному процессу (бизнес-процессу) элементы (подпроцессы в VAD). 
