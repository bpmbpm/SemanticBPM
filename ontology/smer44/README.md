### Ontology. Предложения smer44



Пет-проэкт который я задумал довольно давно
и не интенсивно но всё же занимаюсь это
проэкт онтологии **всех** понятий и смыслового движка (вроде ризонера)
на ней. Позже я переберу мои старые проэкты (Python) и выложу тут что 
можно бы использовать.

### Intro

Подобно тому, как **ограниченным** количеством слов естественного языка
можно выразить **любой** смысл, эта онтология тоже позволит выразить любой смысл в 
своих терминах, скажем так  "искуственно созданных словах", при этом 
избегая недостатков естественного языка таких как множественные смыслы,
неточность одного смысла, слова, смысл которых раскрывается из контекста сложным
образом, небуквальное прочтение и тому подобное, подробнее этим занимается Natural Language Processing,
точнее уже практически не занимается, потому что современные LLM хоть и не доверительны 
в принятии решения или реальной анализе задачи, зато вроде бы закрыли задачу распознавания
смысла в тексте, только вот нужен бы проэкт перевода этого в формальный вид.

Атом онтологии это результат кластеризации происходящего из реального мира. Основной принцип
символьного обучения в том что мы распознаём феномены, которые имеют близость друг к другу
(признаковую - когда наблюдается одно и то же, близость в пространстве или по времени) и объединяем их
в одно понятие. Что такое абстрактное понятие пока об этом не будем тут.
Примерно так возникают слова естественного языка, только из за хаотичности процесса это делается
как попало.  Впрочим их можно взять как предмет рассмотрения, вместе с искуственными языками 
такими как TokiPona, Lojban, Itkuil, недавно добавил конланг Антона Колонина.
и кстати и языками программирования или скриптовыми ЯП (стандарт и  библиотеки) 
для обработки и выделения понятий оттуда.

Принцип ориентирования на них в том, что если в разных языках присутствует одинаковый смысловой атом,
это признак того что он кластеризирован рационально и этот атом следует внести в свою онтологию, 
впрочим это не универсальное правило. С каждый понятием надо разбираться отдельно и большую роль
в этом играет личное искусство и ... скажем так талант чётко формулировать понятия и связи между
ними, примерно как задать правильный дизайн классов в ООП, чтобы там не было разного рода бардака.

Я бы мог изложить тут результат моего рассмотрения разных языков, 
наверно если интересно потом в другом документе. 
Независимо от существующих проэктов (я тогда о них не знал или их не было),
я создал правила создания и ***начало*** онтологии классов (= модели) по ним. 
коротко можно сказать там примерно начинается как существующие tops - онтологии,
немного всё же не так и важное там в более мелких деталях,
которые создают модель на которой могут работать размышления любого смысла
в отличии от 
от игрушечной, например 
- ограниченной в одной области 
_например онтология бизнес процессов без привязки её к онтологии верхнего уровня 
и тогда вы не можете ответить на вопрос что именно такое бизнес процесс.

- или где отношения заданы произвольно как попало и как удобнее 
в данной ситуации задающему человеку, например почему то захотелось отношение 
город -> пиццерия -> тип пиццы и всё, 
и на этом никакого размышления любого смысла не будет а максимум примитивный инференс._

#### Наследование

Классы онтологии организованы в иерархию наследования (допускается множественное).
Принцип подстановки Липскоу используется так что подкласс имеет поля, которые являются подклассами тех же 
полей родительского класса, либо по крайней мере наследуются без изменений. Поле которое не указано 
считается за "что угодно". По моему мнению один из ключевых моментов онтологии хорошего качества это правильная 
архитектура по наследованию, в противовес разного рода проэктам где это считается не столь важным или 
вообще отсутствует. 
Кроме наследования есть и другие типы иерархий типа часть-целое, перед/после, или что "в чём то " расположено.

Определение экземпляра класса это по сути такое же наследование, просто мы считаем эту сущность экземпляром.
Соответственно любая функция мышления применимая к классам может применяться если подставить
туда экземпляр. 
Но по моему мнению не стоит смешивать эти понятия и считать что экземпляр может играть роль класса в других
отношениях, это создаёт бардак в архитектуре.


#### Что такое бизнес процесс 

Напишу размышления на ходу.
Пусть пока что это некий подкласс  События - распостранённое occurent, у меня Event,
но вот какие признаки отличают его от других событий не бизнес процессов. 
- Может, бизнес процесс это ***действие***?

  Действие это:
  - событие( =occurent понятие растянутое во времени) 
  - с субъектом(или многими) (некой разумной активный объектом(=continuant, вневременное понятие) 
  - который намеренно(он разумный) 
  - каузирует(приводит это событие к возникновению)  (дополнение - или использует существующие не каузированное)
  
  Примеры : падение дерева от ветра это не действие, а вырубка деревьев это действие. 
  Но тут есть тот момент, что вообще то каузация события не обязательна. Если деревья сами бы падали без их вырубки, 
  а вам это было бы нужно это тоже было бы бизнес процессом, в котором вам и вырубать их не надо.

- Итак не обязательно что каузирует. Может лучше вариант что бизнес процесс это действие которому субъект  конвенционально присваивает 
утилитарную цель.
  - Конвенционально присваивается (у меня Assigned) - некий признак, который не существовал бы без разумного субъекта который намеренно
  выдумал что этот признак присваивается. Пример это социальные, юридические и политические понятия. Понятие страна не 
  существует само по себе изначально в реальном мире - есть только участок земли, которому люди искуственно придумывают
  что тут находится некая страна. В противовес например понятию материк, который не конвенциональный и у которого 
  есть детектируемые физ. границы.
  - Утилитарная цель. Пока что не скажу. Возможно потребуется нехилый бреншторм вместе с ChatGPT. Просто тут начинается 
  размазывание понятия. Если вы сходили на вечеринку, это не бизнес процесс, а вот была ли для вас была ли в этом утилитарная цель?
  
  - При этом разумеется нежелательно (по моим правилам создания онтологии) создавать ничего не объясняющие, тавтологические или ад хок 
  определения. **Например бизнес процесс это любое событие, которому вы конвенционально присвоили что это бизнес процесс**. 
  Алгоритм размышлений  как машинный так и человеческий продвинется меньше в размышлениях на таких понятиях. 

Видите как непросто оказывается точно описывать понятия.

### DSL

Пока что рабочее имя моего DSL для описания онтологии Laconic, потому что  
ставилась как важные фичи краткость, читабельность, удобство редактирования и 
как результат отсутствие перегруженности спец. символами и конструкциями. 

Эту тенденцию вы можете видеть в тренде того что XML наконец то постепенно 
заменяется на JSON. Должно быть пройдёт ещё лет 20 и сообщество поймёт что 
лучше работать с чем то вроде YAML.

по поводу RFD и Turtle.
На мой взгляд нежелательны фокусы с прописыванием URI- адреса
прямо в тексте файла с онтологией, если нужно то пишите в
другом файле в формате имя - значение. Нежелательно использование сложных 
ссылок типа namespace::object и ненужных спецсимволов, это ухудшает читабельность и редактируемость.

Внутри моей онтологии не нужны URI и namespaces - она описывается изначально
так чтобы описать любое понятие, то есть внутри общего своего namespace-а 
а при переводе очевидно надо будет составлять  соответствие, но его бы прописывал отдельно.

Если у вас будет онтология хотя бы в 1000 понятий с их отношениями,
а если вы знаете, то лексический минимум языка это несколько тысяч понятий,
и примерно после этого модель становится способной отобразить любой смысл.
Для сравнения, 
- TokiPona с примерно 200 +- слов при этом расплывчатые понятия 
ещё несколько недостаточна, вы это увидите если начнёте в неё переводить,
- несколько тысяч - это минимум использования естественного языка
- иностранного языка, а в C2 владения языком  - от 6000 слов.


При этом ничто не мешает сохранять ту же экспрессию или даже больше.

Чтобы понять ***насколько*** я урезал спецсимволы, приведу такой пример.
Описание сущности состоит из описания названия и её полей с отступом, отступ 
как в Python. Рациональность использования отступа в том, что всё равно если вы 
используете скобки, вы для форматирования кода например в С всё равно используете
отступы, таким образом скобки становятся избыточными.
Описания класса в онтологии это:
```
class <className>  <parentClassName1> <parentClassName2>
    <relation_name>  <class_relation_to>
```
например
```
class BusinessProcess Event Assigned
     purpose Info
```
И это всё что нужно.
Поэтому когда рассматриваешь такую нотацию например 
```xml 
    <owl:AnnotationProperty rdf:about="http://www.ontonet.ru/ontology/realm/d4a500e1-133b-4062-8e92-6c498d431db6#incomingRole">
        <rdfs:comment>Incoming role</rdfs:comment>
    </owl:AnnotationProperty>

```
или даже
```turtle
:Process_1_1
	rdfs:type vad:ProcessType ;
        vad:hasParent :Process_1 ;
	vad:hasNext :Process_1_2 .
```

Не возникает желание ей реально пользоваться.

Может существовать эквивалент записи в одну строку если вам почему то надо так описать сущность.
```
class BusinessProcess Event Assigned purpose Info
```
Уже это однозначная запись если имя класса вы используете с заглавной буквы.
Но можете ввести скобки по-кодерски 

```
class BusinessProcess (Event, Assigned, purpose: Info)
```

Пример урезания в том что некоторое время была диллема оставить ли двоеточие 
после <className> или запятые между parent так чтобы заголовок выглядел 
как в более ранней "версии":

class BusinessProcess: Event, Assigned

И в конце концов я это убрал символы ":,"  после некоторого времени работы где я неоднократно
переписывал онтологию. 
Если вы решите переписать так что убираете родительские классы, вы лишний раз
постоянно удаляете или прописываете опять  символы, которые избыточны 
потому что запись интерпретируется и без них в то время как двойной клик + delete
быстрее удаляет одно слово. Вот только по этому.
Какая дополнительная работа по редактированию проводилась бы если бы это было
написано в XML, JSON, всякие там Turtle, при этом рабочего размера то есть в тысячи понятий.


Эклемпляр класса описывается как 

<class_name> <var_name>
    <relation_name>  <relation_instance> (возможна вложенность)

или экземпляр может быть анонимным когда он вложен тогда <var_name> отсутствует.
Или заголовок может быть <var_name> = <class_name>
Тут ещё надо определиться как удобнее окажется в процессе работы.

Для примера переведу  ваш vad_2.ttl:

закупка = Process
   label str Закупка материалов 

- Можно ли считать что считаются строками прочие 
литералы по умолчанию?
Для строк, писать постоянно кавычки "" раздражает
кроме того в онтологии нет разницы между строкой
и литералом который не кодовое слово и не имя
переменной в скопе ( имя класса или экземпляра)

Кстати может быть некий механизм автонейминга чтобы не 
прописывать полем экземпляра его имя, потому что 
тогда такие вот определения избыточны.



```
нарезка = Process
  label Нарезка проволоки 

сгибание = Process 
  label Сгибание проволоки

фасовка = Process 
  label Фасовка проволоки

хранение = Process 
  label Складское хранение

иванов = Person
  personalName Иванов

петров = Person
  personalName Петров

сидоров = Person
  personalName Сидоров
```
либо можно расширить так чтобы вы могли написать 
```

Process нарезкаПроволоки, сгибаниеПроволоки, фасовкаПроволоки, хранениеПроволоки
Person иванов, петров, сидоров

```
с авто-неймингом, где поле присваивается по имени переменной 
с преобразованием составной нотации (через заглавную букву или символ _) в отдельные слова




Как я бы описал сам этот класс Process:
```
class Process Action
  label Info  #а что это такое? Опускаем это при автонейминге
  делает* IntelligentActive # * значит 1-n но тут могут быть детали
  -* Process  #тразниция на последующие процессы, поле можно задавать не занятым символом 
```
Тогда можно задать дальше как 
```
нарезка - сгибание
сгибание - фасовка
фасовка - хранение

нарезка делает иванов петров #или может всё таки добавить тут запятую чтобы выглядело
нарезка делает иванов, петров # с явным обозначением 

сгибание делает сидоров 

фасовка делает иванов петров

#а кто делает хранение?
```
Этот формат довольно просто парсить, я сделал парсинг в объекты Python, 
потом пересмотрю и выложу.
А детали для начала в том, нужно ли размечать поля которые 
должны обязательно присутствовать - быть известными у экземпляра, я пока 
что беру что необязательно, потому что в любой момент может поступить
экземпляр в котором что то неизвестно и движок должен с этим работать.


### Conlang

На понятиях заданных таким образом можно создать искуственный упрощённый язык Сonlang
который с одной стороны более похож на человеческий, но его можно просто парсить и в нём нет
неоднозначностей и он может точно задать данные.
Текст на конлаге состоял бы из предложений с примерно таким синтаксисом
```
(varName =)? (subject subjectAttribute*)* action actionAttribute* (object objectAttributes*)* pronounPhrase* 
```
И написать что то вроде 
```
нарезка сгибание фасовка хранение : действие
иванов петров сидоров : физЛицо
первое = иванов петров делает нарезка 
второе = сидоров делает сгибание после первое  
третье = иванов петров делает фасовка после второе 
делает хранение после третье 
```
Где двоеточие это глагол быть экземпляром чтобы не писать 
нарезка сгибание фасовка хранение быть_экземпляром действие.

Пока что остаётся открытым вопрос, удобно ли будет пользоваться чем то таким,
и нужен ли отдельный язык для этого либо те же утверждения можно прописать предыдущим DSL 
который при некой модификации позволит писать конструкции подобные этому.

### GUI 

Имея граф из таких объектов можно их отобразить визуально и редактировать.
Я начал делать GUI для этого на Python, сделал начальное авто размещение просто из структуры графа.
Но там остались вопросы насколько красиво это выглядит, либо в ваших примерах компоненты
размещаются на особых местах например документ всегда слева, работник всегда справа.
Я потом посмотрю есть ли функции авторазмещения в yEd.
Ещё я начинал работать в Protege и UmLet но отказался из за неудобств в них.

На данный момент задумка в том чтобы иметь слева текстовое окно с графом
не всем, а с функцией выделения выборки узлов и типа связей с которыми вы работаете,
и соответственно только выборка отображается в текстовом окне и в графическом редакторе справа.
Потому что узлов и связей из одного узла может быть  много, что сделает редактирование затруднительным.

В графическом редакторе справа вам будут удобны следующие функции
- авторазмещение компонент
- выравнивание как в yEd
- выборка всего поддерева выбранного узла чтобы его можно было переместить.
- выбор только прямых детей выбранного узла
- фильтр по типу связей между узлами
- переход в текстовом окне в текст кода выбранного в графическом редакторе объекта
- объект может быть сложным тогда при клике он может раскрываться примерно как редактор в Unreal


### Применение
Для меня это был проэкт онтологии любого смысла вообще, и со временем появился интерес
задать DSL для игровой логики (вообщем симуляций и как более узкие случаи 
для пошаговых игр), пока что в разработке его вид. Например там с одной стороны 
было бы практично задать условия "if" или циклы "for" внутри экземпляра, но этого не было в изначальной задумке DSL,
там ветвления задавались подклассами .
Так что пока что думаю. Ещё часто нужно задавать действия которые выполняются автоматически
при другом событии, что примерно эквивалентно Listener-ам в ООП, например 
вызов события "при возникновении/исчезании объекта/неком событии", ожидание события, 
из стандартных функций нужны в первую очередь поиск пути, поиск ближайшего объекта / или какого то определённого типа, 
транзиция в другое состояние по сложному условию.

Когда нужны условия и циклы, и нужны ли они 

Допустим у вас есть склад, где разные типы товаров имеют разное количество полей и с ними производятся
разные действия. 
(псевдокод на пока что не на моём DSL а на неопределённом языке )
```
class складируемое
  при получении:
    if .type == "машина":
      поместить Гараж
    else:
      if .хрупкое:
        поместитьАккарутно склад
      else 
        поместить склад
```
Обычно по нормам дизайна приложения это задавалось бы подклассами, без "if" ветвлений внутри самого класса например

```
class складируемое
   приПолучении поместить хранилище 
   
class поместитьАккарутно поместить

class машина складируемое
  приПолучении поместить Гараж
    
class хрупкий_товар складируемое 
  приПолучении поместитьАккарутно склад
    
class товар складируемое
  приПолучении поместить склад   
```
Вроде красивая нотация.
Но во первых это редундантная (повторяющаяся, вербозная ) запись.
Далее на практике бывает удобнее прописывать это в одном if в ряде случаев, можно было бы разобрать. 
Может это удобство из разряда что если у кодера руки стали кривыми то ими удобно и работать по кривому.

Скажем так, если есть некое условное отношение которое хуже задаётся декларативно и "stateless".
Условия могут быть реал-таймовыми а не времени декларации, потом посмотрю случаи.
Ну вот сходу например если склад заполнен почти полностью с поступающим товаром делать что то другое.
тогда менее рационально описывать некую странную сущность 
class товарПриЗаполненномСкладе 


### Алгоритмы мышления 
Это должна быть самая интересная часть.
Изначальная задумка была о механизмах мышления на онтологии всех понятий, но я ещё не доделал модель.
Вы можем выделить следующие примитивные функции

валидация - проверить что сушность это подмножество другой сущности. 
логические и, или, xor, вычитание
поиск пути по графу.
мутация, композиция ( соединение частей имеющегося).

Как более общий вариант, "map"  функции применительно к графам. Он состоит 
из атомарной и агрегационной функции с нейтральным элементом, или агрегационной функции
может не быть и тогда ответом будет граф.
При применении любой map сложному объекту, применяется атомарная функция к каждой паре его полей,
если поле сложное то перед этим (соответсвенно в поряке dfs)  вычисляется результат применения
этого map к сложному полю и это поступает как аргумент атомарной функции. 
после расчёта всех атомарных функций по всем полям сложного объекта, к результату применяется агрегационная функция

возмём для примера логическое "И"

имея and(obj, other) , где оба этих объекта сложные. Мы применяем обычное логическое "и" к каждой 
паре одинаковых полей, что бы это не значило для типа в каждой паре. 
Например если они имеют поля weight, size, reference:

arg1 = and_a (obj.weight,other.weight)
arg2 = and_a (obj.size,other.size)
arg3 = and_a (obj.reference,other.reference)
но пусть reference само по себе сложное поле у которого имеются свои поля.
тогда вместо  and_a применяется изначальная arg3 = and (obj.reference,other.reference).
потом применяется ф-я агрегации and_aggr(arg1,arg2,arg3) - логическое и по этим результатам 
Если ф-и агрегации нет, то в ответ передаётся объект obj_res  где 

obj.weight =arg1
obj.size =arg2
obj.reference =arg3

- Так мы можем задать валидацию как map  функцию где атомарная пара это "входит в множество"
а аггрегации это логическое И.

- Для того чтобы посчитать общее в ряде утверждений (каждое утверждение это граф понятий)
применяется атомарное логическое И без аггрегации.

- Применить родительский класс к его подклассу это взять атомарное пересечение по всем полям
считая отсутствующее поле в родительском классе как "что угодно" а в подклассе 
как не влияющее на результат. Без аггрегации.

Более сложные примеры или другие функции. 

- Выдвижение гипотез (индукция) по ряду утверждений состоит из некоего логического маппинга
например логическое И по выбранным полям, при этом мы запоминаем допущения при выдвижении гипотез,
такие как контекст ситуации либо поля которые были выбраны. В дальнейшем, эта индукция может
оказаться верной или ложной. После этого мы можем проанализировать контекст дальше в размышлении,
для выяснения почему допущение было верно или неверно например сравнив его с допущениями в других гипотезах,
и так далее.


- Мутацию и композицию можно использовать как другой способ выдвижения гипотез в творческом алгоритме.


- Выдвижение метафор я считаю за поиск пути по графу классов, то есть несколько раз в более общее и потом
в другое более узкое понятие, и потом использование конечного класса как изначального.
Простой пример, разберём метафору "Дерево смотрит." Оно на самом деле не смотрит. Тут переход из понятий
"стоит неподвижно" в более узкое "стоит неподвижно и смотрит" что то вроде "уставилось", и потом в более
широкое понятие "смотрит". Возмём что то другое, часы летят. Тут переход
идут - идут быстро - двигаются быстро - летят (потому что по дефолту летать считается быстро)
но само часы идут это другая метафора. Вам нужно задать что то вроде "время движется"
и заменяем время - час  и движется - идёт. 

Ряд этих функций может образовывать длинный пайплайн. 
Теоретически я из этого ожидаю функционал сложного мышления сравнимого с GPT ***при условии*** что это 
будет реализовано как задуманно.
Пока что никаких точных возражений против этих идей про мышление я не видел.  
Возражения которые мне предъявлялись:

- Нельзя составить онтологию всех понятий по каким то причинам то ли слишком большая то ли начинают что то про жёсткость. 
   - Странно, естественный язык это и есть некая такая онтология правда неоптимального вида, которой можно выразить любое понятие.
Вариабельность понятий создаёт механизм признаков ( Trait) где реальный объект рассматривается как совокупность признаков
которые мы кластеризировали отдельно и объект их наследует. 
- Нельзя выразить абстрактные понятия или сложные понятия мышления. 
  - Когда правильно разбираешь "абстрактное понятие" его вполне удаётся выразить, не встречал трудностей.
- Отношения должны быть 
вероятностными
  - Мышление человека в принятии решений в конечном это не вероятностное а точное (символьное/формальное/смысловое)
Вы не на 55% принимаете решение куда то пойти и что то сделать, а вы принимаете решение из переченя
конкретных факторов с определёнными параметрами. Вы можете сомневаться, но это вы тоже выражаете в точных
смысловых понятиях.
- Приимущество  перед вероятностными методами в точном задании запросов и точном его исполнении с прозрачными
шагами, так что вы можете выделить и модифицировать конкретный шаг который вас заинтересовал после 
последнего результата.

#### НО 
Это всё существует по большей степени в теоретическом виде, по возможности выделяю время.
Недостаток по сравнению с "современными могучими самообучающимися вероятностными методами" в том что начальная реализация 
тут требует более долгой реализации, размышлений по поводу решений и... скорее искусства чем науки в нахождении решений.

### Процессы 
Скорее вложенный процесс это часть/целое по отношению к составному процессу а не parent/child
что скорее зарезервировано для  суперкласс/подкласс

При этом процессы могут по разному следовать друг после друга 
может быть логический И,Или например процесс 3 последует если процесс 1 и 2 выполнены,
либо выполнен только 1 из них. 

## upd1 bpmbpm
Язык бизнес-процессов (не путать с BPMN, которые не про процессы, а только про workflow) – наверное хорошая идея: типа некий скриптовый язык, который более приспособлен к их описанию чем универсальный RDF\OWL.  

__ограниченной в одной области _например онтология бизнес процессов без привязки её к онтологии верхнего уровня и тогда вы не можете ответить на вопрос что именно такое бизнес процесс.__

Да, с этого бы начать, т.е. с локальной онтологии (маленькой онтологии «простой бизнес-процесс»). При этом хотелось бы параллельно ее встраивать в код MVP, т.е. сразу использовать в семантических конструкциях (триплетах).

_Что такое бизнес процесс. Напишу размышления на ходу._ 

События (event ARIS EPC \ BPMN) и т.п. это элемент workflow (если на них смотреть совсем "приземленно"). Давайте начнем с более простого – с VAD и применим эту мини-онтологию (без событий) в MVP. В базовом VAD нет событий.  

**Предлагаю идти параллельно:** теоретическая проработка интересных «Предложений smer44» (точнее тех материалов, которые он опубликует) и 
### MVP
включая  проработку и програмную реализацию более понятной задачи: закодировать ARIS (точнее publisher для VAD-diagram) через RDF с поддержкой встроенного (в наш BPMS) SPARQL. 
При этом создать мини-онтологию для процесса, достаточную для обработки в объеме VAD нотации. Уже это совсем непростая задача.  

Фактически мы во внешней оболочке – аналоге publisher, например, простой статический сайт типа первого [ARIS Web Publisher](http://www.bpm.processoffice.ru) реализуем обработку RDF файлов и механику взаимодействия GUI через SPARQL, т.е. как бы SPARQL сделаем внутренним языком манипуляций пользователя с системой (ARIS Publisher). Точнее за каждой кнопкой в GUI будет стоять SPARQL – запрос («что отображать») и конечно управление нужными окошками («как отображать»). 
При этом будем использовать стандартные open source библиотеки как для формирования GUI и рендеринга графических файлов (схем процессов), так и для обработки в части Linked Data. 
Иными словами MVP: Внешне ARIS Publisher, а внутри Linked Data (включая онтологию). На первом этапе только в части VAD. И разные «бантики» типа: по схемам строить всякие матрицы RACI и т.п., также через SPARQL). 
Я как бы не против «журавля» («DSL для описания процессов» и т.п.), но хотелось бы приоритет оставить за «синицей – MVP» (быстро и что-то работающее и на более понятных принципах).   

В [ProcessMetaModel](https://github.com/bpmbpm/SemanticBPM/blob/main/method/process_codification/ProcessMetaModel.md) хотелось бы как раз утвердить подход реализации MVP, минимальную онтологию, кодировку всех элементов (включая, URL для файлов с графическими схемами), которые можно уже использовать для кодирования (построения MVP). 

Отдельные моменты:
_либо в ваших примерах компоненты размещаются на особых местах например документ всегда слева, работник всегда справа. Я потом посмотрю есть ли функции авторазмещения в yEd._

Да, это важный аспект: у схемы ЕРС слева слой «docflow / materflow», далее слой workflow (event + function) и справа ресурсы процесса (исполнители и инструменты). Если схема перегружена, то можно отключать слои. Такого подхода обычно не придерживаются и явно его формализации я не видел. В yEd не знаю, как, но в drawio (думаю и в visio) так можно (задавать сторону света), см. пример в excel: [SemanticBPM/samples/vad_1/vad_1.xlsm](https://github.com/bpmbpm/SemanticBPM/blob/main/samples/vad_1/vad_1.xlsm)
Также см. файл Книга1_w10.xlsm [SemanticBPM/docs/drawio/Excel_to_drawio/Ex1/](https://github.com/bpmbpm/SemanticBPM/tree/main/docs/drawio/Excel_to_drawio/Ex1). Где-то у меня есть более сложные примеры (ветвление процессов).  

Однако: Эти упражнения (документ всегда слева и т.п.) нам понадобятся потом – когда мы дойдем до ЕРС (если вообще дойдем), но сейчас хотелось бы научиться делать куда более простые вещи: совсем простой VAD. 


